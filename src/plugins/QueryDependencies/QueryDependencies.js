/*globals define*/
/*jshint node:true, browser:true, esnext: true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Tue Dec 08 2015 12:17:05 GMT-0600 (CST).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase'
], function (
    PluginConfig,
    PluginBase
) {
    'use strict';

    /**
     * Initializes a new instance of QueryDependencies.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin QueryDependencies.
     * @constructor
     */
    var QueryDependencies = function () {
        // Call base class' constructor.
        PluginBase.call(this);
    };

    // Prototypal inheritance from PluginBase.
    QueryDependencies.prototype = Object.create(PluginBase.prototype);
    QueryDependencies.prototype.constructor = QueryDependencies;

    /**
     * Gets the name of the QueryDependencies.
     * @returns {string} The name of the plugin.
     * @public
     */
    QueryDependencies.prototype.getName = function () {
        return 'QueryDependencies';
    };

    /**
     * Gets the semantic version (semver.org) of the QueryDependencies.
     * @returns {string} The version of the plugin.
     * @public
     */
    QueryDependencies.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    QueryDependencies.prototype.main = function (callback) {
        // Get all connections
        this.core.loadChildren(this.activeNode, (err, children) => {
            let connections,
                nodeName = this.core.getAttribute(this.activeNode, 'name'),
                zipFile,
                prologRules,
                nodeDict = this.createNodeDict(children);

            if (err) {
                return callback(err);
            }

            // Get the connections
            connections = children.filter(child => this.isMetaTypeOf(child, this.META.requiredFor));

            // Generate a prolog rule for each of them
            prologRules = connections
                .map(this.createPrologRule.bind(this, nodeDict));

            // Add a couple prolog rules
            prologRules.push('requiredFor(X, Y) :- requires(X, Y).');
            prologRules.push('requiredFor(X, Y) :- requires(Z, Y), requiredFor(X, Z).');
            prologRules.push('allDependencies(Item) :-  setof(X, requiredFor(X, Item), Set), ' +
              'print(Set).');

            // Save the code
            this.saveFile(nodeName + '.pl', prologRules.join('\n'), callback);
        });

    };

    QueryDependencies.prototype.saveFile = function (name, content, callback) {
        let zipFile = this.blobClient.createArtifact(name.replace('.pl',''));
        zipFile.addFile(name, content, e => {
            this.blobClient.saveAllArtifacts((err, hashes) => {
                this.save('QueryDependencies updated model.', err => {
                    if (err) {
                        callback(err, this.result);
                        return;
                    }
                    this.result.setSuccess(true);
                    this.result.addArtifact(hashes[0]);
                    callback(null, this.result);
                });
            });
        });
    };

    QueryDependencies.prototype.createPrologRule = function (nodeDict, connection) {
        var names;

        names = ['src', 'dst']
            .map(ptr => this.core.getPointerPath(connection, ptr))
            .map(nodeId => nodeDict[nodeId])
            .map(node => this.core.getAttribute(node, 'name'))
            .map(name => name.toLowerCase().replace(/ /g, '_'));

        // Create statements like this:
        //   requires(<srcName>, <dstName>).
        return `requires(${names[0]}, ${names[1]}).`;
    };

    QueryDependencies.prototype.createNodeDict = function (nodes) {
        var result = {};
        nodes
            .map(node => this.core.getPath(node))  // Get the paths
            .forEach((id, index) => result[id] = nodes[index]);

        return result;
    };

    return QueryDependencies;
});
